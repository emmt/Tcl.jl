"""

Glue code to Tcl C library.

The convention is to call the functions of the Tcl C library with raw arguments (like
pointers). The only changes are:

 - Tcl status code is returned as a `TclStatus`.

 - Return values passed by reference to a C function are not needed in the Julia interface
   and are returned as tuple of values.

 - Values representing a length or an index are returned as an `Int` (not a `Cint`);

 - Values representing a boolean (a `Cint` in Tcl, a `Bool` in Julia) are automatically
   converted using consistent conventions.

 - Indices account for Julia convention (Julia indices start at 1, Tcl indices start at 0).

"""
module Glue

using Tcl_jll
using Tk_jll
using CEnum

"""
    TclStatus

Type of result returned by evaluating Tcl scripts or commands. Possible values are:

* `TCL_OK`: Command completed normally; the interpreter's result contains the command's
  result.

* `TCL_ERROR`: The command couldn't be completed successfully; the interpreter's result
  describes what went wrong.

* `TCL_RETURN`: The command requests that the current function return; the interpreter's
  result contains the function's return value.

* `TCL_BREAK`: The command requests that the innermost loop be exited; the interpreter's
  result is meaningless.

* `TCL_CONTINUE`: Go on to the next iteration of the current loop; the interpreter's result
  is meaningless.

"""
@cenum TclStatus::Cint begin
    TCL_OK       = 0
    TCL_ERROR    = 1
    TCL_RETURN   = 2
    TCL_BREAK    = 3
    TCL_CONTINUE = 4
end

# Procedures to be called by Tcl can be generated by `@cfunction` which returns a
# `Ptr{Cvoid}`.
const Tcl_CmdDeleteProc = Cvoid
const Tcl_CmdProc = Cvoid
const Tcl_FreeProc = Cvoid
const Tcl_IdleProc = Cvoid
const Tcl_ObjCmdProc = Cvoid

# Flags for settings the result.
const TCL_VOLATILE = Ptr{Tcl_FreeProc}(1)
const TCL_STATIC   = Ptr{Tcl_FreeProc}(0)
const TCL_DYNAMIC  = Ptr{Tcl_FreeProc}(3)

# Flags for Tcl variables.
const TCL_GLOBAL_ONLY    = Cint(1)
const TCL_NAMESPACE_ONLY = Cint(2)
const TCL_APPEND_VALUE   = Cint(4)
const TCL_LIST_ELEMENT   = Cint(8)
const TCL_LEAVE_ERR_MSG  = Cint(0x200)

# Flags for Tcl processing events.  Set TCL_DONT_WAIT to not sleep: process
# only events that are ready at the time of the call.  Set TCL_ALL_EVENTS to
# process all kinds of events: equivalent to OR-ing together all of the below
# flags or specifying none of them.
const TCL_DONT_WAIT     = Cint(1<<1)
const TCL_WINDOW_EVENTS = Cint(1<<2) # Process window system events.
const TCL_FILE_EVENTS   = Cint(1<<3) # Process file events.
const TCL_TIMER_EVENTS  = Cint(1<<4) # Process timer events.
const TCL_IDLE_EVENTS   = Cint(1<<5) # Process idle callbacks.
const TCL_ALL_EVENTS    = ~TCL_DONT_WAIT      # Process all kinds of events.

# The following values control how blocks are combined into photo images when
# the alpha component of a pixel is not 255, a.k.a. the compositing rule.
const TK_PHOTO_COMPOSITE_OVERLAY = Cint(0)
const TK_PHOTO_COMPOSITE_SET     = Cint(1)

# Flags for evaluating scripts/commands.
const TCL_NO_EVAL       = Cint(0x010000)
const TCL_EVAL_GLOBAL   = Cint(0x020000)
const TCL_EVAL_DIRECT   = Cint(0x040000)
const TCL_EVAL_INVOKE   = Cint(0x080000)
const TCL_CANCEL_UNWIND = Cint(0x100000)
const TCL_EVAL_NOERR    = Cint(0x200000)

# Tcl wide integer is 64-bit integer.
const Tcl_WideInt = Int64

# Client data used by commands and callbacks.
const ClientData = Ptr{Cvoid}

# Opaque structures.
abstract type Tcl_ObjType end
abstract type Tcl_Obj end
abstract type Tcl_Interp end
abstract type Tcl_Command_ end
abstract type mp_int end

# Token used by Tcl to identify an object command.
const Tcl_Command = Ptr{Tcl_Command_}

#------------------------------------------------------------- Inference and introspection -

# Return the least multiple of `b` that is greater or equal `a`. `a` and `b` must be
# non-negative.
roundup(a::Integer, b::Integer) = roundup(promote(a, b)...)
roundup(a::T, b::T) where {T<:Integer} = div(b - one(T) + a, b)*b

# Return the alignment in a C structure of an object of type `T`.
alignment(::Type{T}) where {T} = fieldoffset(Tuple{UInt8,T}, 2)

#----------------------------------------------------------------------------- Tcl objects -

"""
    FakeObj{T,N}

Julia equivalent type of C structure `Tcl_Obj` assuming member `internalRep` is of type `T`
and preceded by a padding of `N` bytes. This is used to compute the types and offsets of the
fields of a `Tcl_Obj` and the full size of a `Tcl_Obj`.

The definition of `Tcl_obj` in `<tcl.h>` is:

```c
typedef struct Tcl_ObjType Tcl_ObjType;
typedef struct Tcl_Obj {
    int refCount;
    char *bytes;
    int length;
    const Tcl_ObjType *typePtr;
    union {
        long longValue;
        double doubleValue;
        void *otherValuePtr;
        Tcl_WideInt wideValue;
        struct {
            void *ptr1;
            void *ptr2;
        } twoPtrValue;
        struct {
            void *ptr;
            unsigned long value;
        } ptrAndLongRep;
    } internalRep;
} Tcl_Obj;
```

"""
struct FakeObj{T,N}
    refCount::Cint
    bytes::Ptr{Cchar}
    length::Cint
    typePtr::Ptr{Tcl_ObjType}
    padding::NTuple{N,UInt8}
    internalRep::T
end

# Tuple of possible types in `internalRep` union.
const Tcl_Obj_internalRep_types = (Clong, Cdouble, Ptr{Cvoid}, Tcl_WideInt,
                                   Tuple{Ptr{Cvoid}, Ptr{Cvoid}},
                                   Tuple{Ptr{Cvoid}, Culong})

# Define constants for the types and offsets of all fields but the last ones.
for (index, name) in enumerate(fieldnames(FakeObj{Nothing,0}))
    name == :padding && break
    @eval begin
        const $(Symbol("Tcl_Obj_",name,"_type")) = $(fieldtype(FakeObj{Nothing,0}, index))
        const $(Symbol("Tcl_Obj_",name,"_offset")) = $(fieldoffset(FakeObj{Nothing,0}, index))
    end
end

# Alignment of `internalRep` union is the maximal alignment of the different possible types.
const Tcl_Obj_internalRep_align = maximum(map(alignment, Tcl_Obj_internalRep_types))
const Tcl_Obj_internalRep_offset = roundup(sizeof(FakeObj{Nothing,0}), Tcl_Obj_internalRep_align)
const Tcl_Obj_internalRep_pad = Tcl_Obj_internalRep_offset - sizeof(FakeObj{Nothing,0})

# NOTE The number of padding bytes `N` must be an `Int` otherwise the result is wrong.
const Tcl_Obj_size = maximum(map(T -> sizeof(FakeObj{T,Int(Tcl_Obj_internalRep_pad)}),
                                 Tcl_Obj_internalRep_types))

# NOTE Some initialization are needed before calling `TclFreeObj`. This may be done by
#      creating an interpreter.
function TclFreeObj(obj)
    @ccall libtcl.TclFreeObj(ptr::Ptr{Tcl_Obj})::Cvoid
end

function Tcl_DuplicateObj(objPtr)
    @ccall libtcl.Tcl_DuplicateObj(objPtr::Ptr{Tcl_Obj})::Ptr{Tcl_Obj}
end

function Tcl_GetObjType(typeName)
    @ccall libtcl.Tcl_GetObjType(typeName::Cstring)::Ptr{Tcl_ObjType}
end

# Numbers.
#
# NOTE In object accessors, the interpreter may be NULL, if non-NULL, it is only used to
#      store an error message in case of failure.
#
for (name, type) in ("Boolean" => :Cint,
                     "Int"     => :Cint,
                     "Long"    => :Clong,
                     "Double"  => :Cdouble,
                     "WideInt" => :Tcl_WideInt,
                     )
    creator = Symbol("Tcl_New",name,"Obj")
    mutator = Symbol("Tcl_Set",name,"Obj")
    accessor = Symbol("Tcl_Get",name,"FromObj")
    @eval begin
        function $creator(val)
            @ccall libtcl.$creator(val::$type)::Ptr{Tcl_Obj}
        end
        function $mutator(obj, val)
            @ccall libtcl.$mutator(obj::Ptr{Tcl_Obj}, val::$type)::Cvoid
        end
        function $accessor(interpr, obj, ptr)
            @ccall libtcl.$accessor(interp::Ptr{Tcl_Interp}, obj::Ptr{Tcl_Obj},
                                    ptr::Ptr{$type})::TclStatus
        end
    end
end

# Strings.

function Tcl_NewStringObj(str, len)
    @ccall libtcl.Tcl_NewStringObj(str::Ptr{UInt8}, len::Cint)::Ptr{Tcl_Obj}
end

function Tcl_SetStringObj(obj, str, len)
    @ccall libtcl.Tcl_SetStringObj(obj::Ptr{Tcl_Obj}, str::Ptr{UInt8}, len::Cint)::Cvoid
end

function Tcl_GetStringFromObj(obj, lenptr)
    @ccall libtcl.Tcl_GetStringFromObj(obj::Ptr{Tcl_Obj}, lenptr::Ptr{Cint})::Ptr{UInt8}
end

# Multi-precision integers. TODO "Bignum" => :BigInt

function Tcl_NewBignumObj(value)
    @ccall libtcl.Tcl_NewBignumObj(value::Ptr{mp_int})::Ptr{Tcl_Obj}
end

function Tcl_SetBignumObj(obj, value)
    @ccall libtcl.Tcl_SetBignumObj(obj::Ptr{Tcl_Obj}, value::Ptr{mp_int})::Cvoid
end

function Tcl_GetBignumFromObj(interp, obj, value)
    @ccall libtcl.Tcl_GetBignumFromObj(interp::Ptr{Tcl_Interp}, obj::Ptr{Tcl_Obj}, value::Ptr{mp_int})::Cint
end

function Tcl_TakeBignumFromObj(interp, obj, value)
    @ccall libtcl.Tcl_TakeBignumFromObj(interp::Ptr{Tcl_Interp}, obj::Ptr{Tcl_Obj}, value::Ptr{mp_int})::Cint
end

# Byte arrays.

function Tcl_NewByteArrayObj(bytes, numBytes)
    @ccall libtcl.Tcl_NewByteArrayObj(bytes::Ptr{Cuchar}, numBytes::Cint)::Ptr{Tcl_Obj}
end

function Tcl_GetByteArrayFromObj(objPtr, numBytesPtr)
    @ccall libtcl.Tcl_GetByteArrayFromObj(objPtr::Ptr{Tcl_Obj}, numBytesPtr::Ptr{Cint})::Ptr{Cuchar}
end

function Tcl_SetByteArrayLength(objPtr, numBytes)
    @ccall libtcl.Tcl_SetByteArrayLength(objPtr::Ptr{Tcl_Obj}, numBytes::Cint)::Ptr{Cuchar}
end

function Tcl_SetByteArrayObj(objPtr, bytes, numBytes)
    @ccall libtcl.Tcl_SetByteArrayObj(objPtr::Ptr{Tcl_Obj}, bytes::Ptr{Cuchar}, numBytes::Cint)::Cvoid
end

# Reference counting.

function Tcl_Preserve(data)
    @ccall libtcl.Tcl_Preserve(data::ClientData)::Cvoid
end

function Tcl_Release(data)
    @ccall libtcl.Tcl_Release(data::ClientData)::Cvoid
end

# FIXME """
# FIXME ```julia
# FIXME Tcl_IncrRefCount(objptr) -> objptr
# FIXME ```
# FIXME
# FIXME increments the reference count of the object referenced by `objptr` and returns
# FIXME this address.
# FIXME
# FIXME """
# FIXME @inline function Tcl_IncrRefCount(objptr::Ptr{Tcl_Obj})
# FIXME     ptr = Ptr{Cint}(objptr)
# FIXME     unsafe_store!(ptr, unsafe_load(ptr) + one(Cint))
# FIXME     return objptr
# FIXME end
# FIXME
# FIXME """
# FIXME ```julia
# FIXME Tcl_DecrRefCount(objptr) -> nothing
# FIXME ```
# FIXME
# FIXME decrements the reference count of the object referenced by `objptr` and delete
# FIXME it if the number of references is then smaller or equal 0.
# FIXME
# FIXME """
# FIXME @inline function Tcl_DecrRefCount(objptr::Ptr{Tcl_Obj})
# FIXME     ptr = Ptr{Cint}(objptr)
# FIXME     newrefcount = unsafe_load(ptr) - one(Cint)
# FIXME     if newrefcount ≥ 1
# FIXME         unsafe_store!(ptr, newrefcount)
# FIXME     else
# FIXME         ccall((:TclFreeObj, libtcl), Cvoid, (Ptr{Tcl_Obj},), objptr)
# FIXME     end
# FIXME     return nothing
# FIXME end
# FIXME
# FIXME """
# FIXME ```julia
# FIXME Tcl_GetRefCount(objptr)
# FIXME ```
# FIXME
# FIXME yields the reference count of the object referenced by `objptr`.
# FIXME
# FIXME """
# FIXME Tcl_GetRefCount(obj) = unsafe_load(Ptr{Cint}(objptr))
# FIXME
# FIXME
# FIXME """
# FIXME ```julia
# FIXME Tcl_IsShared(objptr)
# FIXME ```
# FIXME
# FIXME yields whether the object referenced by `objptr` is shared; that is, its
# FIXME reference count is greater than one.
# FIXME
# FIXME """
# FIXME @inline Tcl_IsShared(objptr::Ptr{Tcl_Obj}) = Tcl_GetRefCount(objptr) > 1

#------------------------------------------------------------------------ Tcl interpreters -

function Tcl_CreateInterp()
    @ccall libtcl.Tcl_CreateInterp()::Ptr{Tcl_Interp}
end

function Tcl_Init(interp)
    @ccall libtcl.Tcl_Init(interp::Ptr{Tcl_Interp})::Cint
end

function Tcl_InterpDeleted(interp)
    @ccall libtcl.Tcl_InterpDeleted(interp::Ptr{Tcl_Interp})::Cint
end

function Tcl_InterpActive(interp)
    @ccall libtcl.Tcl_InterpActive(interp::Ptr{Tcl_Interp})::Cint
end

function Tcl_IsSafe(interp)
    @ccall libtcl.Tcl_IsSafe(interp::Ptr{Tcl_Interp})::Cint
end

function Tcl_DeleteInterp(interp)
    @ccall libtcl.Tcl_DeleteInterp(interp::Ptr{Tcl_Interp})::Cvoid
end

function Tcl_SetObjResult(interp, obj)
    @ccall libtcl.Tcl_SetObjResult(interp::Ptr{Tcl_Interp}, obj::Ptr{Tcl_Obj})::Cvoid
end

function Tcl_SetResult(interp, result, freeProc)
    @ccall libtcl.Tcl_SetResult(interp::Ptr{Tcl_Interp}, result::Cstring,
                                freeProc::Ptr{Tcl_FreeProc})::Cvoid
end

function Tcl_GetObjResult(interp)
    @ccall libtcl.Tcl_GetObjResult(interp::Ptr{Tcl_Interp})::Ptr{Tcl_Obj}
end

#--------------------------------------------------------------- Evaluation of Tcl scripts -

function Tcl_EvalEx(interp, script, numBytes, flags)
    @ccall libtcl.Tcl_EvalEx(interp::Ptr{Tcl_Interp}, script::Ptr{UInt8}, numBytes::Cint,
                             flags::Cint)::Cint
end

function Tcl_EvalObjEx(interp, obj, flags)
    @ccall libtcl.Tcl_EvalObjEx(interp::Ptr{Tcl_Interp}, obj::Ptr{Tcl_Obj}, flags::Cint)::Cint
end

function Tcl_EvalObjv(interp, objc, objv, flags)
    @ccall libtcl.Tcl_EvalObjv(interp::Ptr{Tcl_Interp}, objc::Cint,
                               objv::Ptr{Ptr{Tcl_Obj}}, flags::Cint)::Cint
end

function Tcl_DoOneEvent(flags)
    @ccall libtcl.Tcl_DoOneEvent(flags::Cint)::Cint
end

function Tcl_DoWhenIdle(proc, clientData)
    @ccall libtcl.Tcl_DoWhenIdle(proc::Ptr{Tcl_IdleProc}, clientData::ClientData)::Cvoid
end

#---------------------------------------------------------------------------- Tcl commands -

function Tcl_CreateCommand(interp, cmdName, proc, clientData, deleteProc)
    @ccall libtcl.Tcl_CreateCommand(interp::Ptr{Tcl_Interp}, cmdName::Cstring,
                                    proc::Ptr{Tcl_CmdProc}, clientData::ClientData,
                                    deleteProc::Ptr{Tcl_CmdDeleteProc})::Tcl_Command
end

function Tcl_CreateObjCommand(interp, cmdName, proc, clientData, deleteProc)
    @ccall libtcl.Tcl_CreateObjCommand(interp::Ptr{Tcl_Interp}, cmdName::Cstring,
                                       proc::Ptr{Tcl_ObjCmdProc}, clientData::ClientData,
                                       deleteProc::Ptr{Tcl_CmdDeleteProc})::Tcl_Command
end

function Tcl_DeleteCommand(interp, cmdName)
    @ccall libtcl.Tcl_DeleteCommand(interp::Ptr{Tcl_Interp}, cmdName::Cstring)::Cint
end

function Tcl_DeleteCommandFromToken(interp, command)
    @ccall libtcl.Tcl_DeleteCommandFromToken(interp::Ptr{Tcl_Interp},
                                             command::Tcl_Command)::Cint
end

function Tcl_GetCommandName(interp, command)
    @ccall libtcl.Tcl_GetCommandName(interp::Ptr{Tcl_Interp}, command::Tcl_Command)::Cstring
end

function Tcl_GetCommandFullName(interp, command, objPtr)
    @ccall libtcl.Tcl_GetCommandFullName(interp::Ptr{Tcl_Interp}, command::Tcl_Command,
                                         objPtr::Ptr{Tcl_Obj})::Cvoid
end

function Tcl_GetCommandFromObj(interp, objPtr)
    @ccall libtcl.Tcl_GetCommandFromObj(interp::Ptr{Tcl_Interp},
                                        objPtr::Ptr{Tcl_Obj})::Tcl_Command
end

#--------------------------------------------------------------------------- Tcl variables -

function Tcl_ObjGetVar2(interp, part1, part2, flags)
    @ccall libtcl.Tcl_ObjGetVar2(interp::Ptr{Tcl_Interp}, part1::Ptr{Tcl_Obj},
                                 part2::Ptr{Tcl_Obj}, flags::Cint)::Ptr{Tcl_Obj}
end

function Tcl_ObjSetVar2(interp, part1, part2, value, flags)
    @ccall libtcl.Tcl_ObjSetVar2(interp::Ptr{Tcl_Interp}, part1::Ptr{Tcl_Obj},
                                 part2::Ptr{Tcl_Obj}, value::Ptr{Tcl_Obj},
                                 flags::Cint)::Ptr{Tcl_Obj}
end

function Tcl_UnsetVar(interp, name, flags)
    @ccall libtcl.Tcl_UnsetVar(interp::Ptr{Tcl_Interp}, name::Cstring,
                               flags::Cint)::TclStatus
end

function Tcl_SetVar2(interp, part1, part2, value, flags)
    @ccall libtcl.Tcl_SetVar2(interp::Ptr{Tcl_Interp}, part1::Cstring, part2::Cstring,
                              value::Cstring, flags::Cint)::Cstring
end

function Tcl_UnsetVar2(interp, part1, part2, flags)
    @ccall libtcl.Tcl_UnsetVar2(interp::Ptr{Tcl_Interp}, part1::Cstring,
                                part2::Cstring, flags::Cint)::Cint
end

function Tcl_GetVar2(interp, part1, part2, flags)
    @ccall libtcl.Tcl_GetVar2(interp::Ptr{Tcl_Interp}, part1::Cstring, part2::Cstring,
                              flags::Cint)::Cstring
end

#------------------------------------------------------------------------------- Tcl lists -
#
# Note that applying a list function to any Tcl object has the side effect of converting the
# object to a list. In principle, non-temporary objects cannot be modified.

function Tcl_NewListObj(objc, objv)
    @ccall libtcl.Tcl_NewListObj(objc::Cint, objv::Ptr{Ptr{Tcl_Obj}})::Ptr{Tcl_Obj}
end

function Tcl_SetListObj(list, objc, objv)
    @ccall libtcl.Tcl_SetListObj(list::Ptr{Tcl_Obj}, objc::Cint,
                                 objv::Ptr{Ptr{Tcl_Obj}})::Cvoid
end

function Tcl_ListObjAppendList(interp, listPtr, elemListPtr)
    @ccall libtcl.Tcl_ListObjAppendList(interp::Ptr{Tcl_Interp}, listPtr::Ptr{Tcl_Obj},
                                        elemListPtr::Ptr{Tcl_Obj})::Cint
end

function Tcl_ListObjAppendElement(interp, listPtr, objPtr)
    @ccall libtcl.Tcl_ListObjAppendElement(interp::Ptr{Tcl_Interp}, listPtr::Ptr{Tcl_Obj},
                                           objPtr::Ptr{Tcl_Obj})::Cint
end

# FIXME """
# FIXME ```julia
# FIXME Tcl_ListObjAppendElement(intptr, listptr, objptr) -> status::TclStatus
# FIXME ```
# FIXME
# FIXME appends the single value referenced by `objptr` to to the end of the list value
# FIXME referenced by `listptr`.
# FIXME
# FIXME The object referenced by `listptr` must not be shared (its reference count must
# FIXME be ≤ 1) otherwise  Tcl will panic (and abort the program).  To avoid aborting,
# FIXME an error is reported.
# FIXME
# FIXME If `listptr` does not already point to a list value, an attempt will be made to
# FIXME convert it to one.
# FIXME
# FIXME If an error occurs while converting a value to be a list value, an error
# FIXME message is left as the result of the interpreter referenced by `intptr` unless
# FIXME it is NULL.
# FIXME
# FIXME """
# FIXME @inline function Tcl_ListObjAppendElement(intptr::Ptr{Tcl_Interp},
# FIXME                                           listptr::Ptr{Tcl_Obj},
# FIXME                                           objptr::Ptr{Tcl_Obj}) :: TclStatus
# FIXME     if Tcl_IsShared(listptr)
# FIXME         msg = "modifying a shared Tcl list is forbidden"
# FIXME         if intptr == C_NULL
# FIXME             warn(msg, once=true)
# FIXME         else
# FIXME             Tcl_SetResult(intptr, msg)
# FIXME         end
# FIXME         return TCL_ERROR
# FIXME     end
# FIXME     return ccall((:Tcl_ListObjAppendElement, libtcl), TclStatus,
# FIXME                  (Ptr{Tcl_Interp}, Ptr{Tcl_Obj}, Ptr{Tcl_Obj}),
# FIXME                  intptr, listptr, objptr)
# FIXME end

function Tcl_ListObjGetElements(interp, listPtr, objcPtr, objvPtr)
    @ccall libtcl.Tcl_ListObjGetElements(interp::Ptr{Tcl_Interp}, listPtr::Ptr{Tcl_Obj},
                                         objcPtr::Ptr{Cint},
                                         objvPtr::Ptr{Ptr{Ptr{Tcl_Obj}}})::Cint
end

# FIXME """
# FIXME ```julia
# FIXME Tcl_ListObjGetElements(intptr, listptr)
# FIXME     -> status::TclStatus, objc::Int, objv::Ptr{Ptr{Tcl_Obj}}
# FIXME ```
# FIXME
# FIXME Does not touch the reference count of the list object and of its elements.
# FIXME
# FIXME """
# FIXME @inline function Tcl_ListObjGetElements(intptr::Ptr{Tcl_Interp},
# FIXME                                         listptr::Ptr{Tcl_Obj})
# FIXME     objc = Ref{Cint}()
# FIXME     objv = Ref{Ptr{Ptr{Tcl_Obj}}}()
# FIXME     return (ccall((:Tcl_ListObjGetElements, libtcl), TclStatus,
# FIXME                   (Ptr{Tcl_Interp}, Ptr{Tcl_Obj}, Ptr{Cint}, Ptr{Ptr{Ptr{Tcl_Obj}}}),
# FIXME                   intptr, listptr, objc, objv),
# FIXME             objc[], objv[])
# FIXME end

function Tcl_ListObjLength(interp, list, lengthPtr)
    @ccall libtcl.Tcl_ListObjLength(interp::Ptr{Tcl_Interp}, list::Ptr{Tcl_Obj},
                                    lengthPtr::Ptr{Cint})::Cint
end

# FIXME """
# FIXME ```julia
# FIXME Tcl_ListObjLength(intptr, listptr) -> status::TclStatus, length::Int
# FIXME ```
# FIXME """
# FIXME @inline function Tcl_ListObjLength(intptr::Ptr{Tcl_Interp}, listptr::Ptr{Tcl_Obj})
# FIXME     lenref = Ref{Cint}()
# FIXME     return (ccall((:Tcl_ListObjLength, libtcl), TclStatus,
# FIXME                   (Ptr{Tcl_Interp}, Ptr{Tcl_Obj}, Ptr{Cint}),
# FIXME                   intptr, listptr, lenref),
# FIXME             convert(Int, lenref[]))
# FIXME end

function Tcl_ListObjIndex(interp, list, index, objPtrPtr)
    @ccall libtcl.Tcl_ListObjIndex(interp::Ptr{Tcl_Interp}, list::Ptr{Tcl_Obj},
                                   index::Cint, objPtrPtr::Ptr{Ptr{Tcl_Obj}})::Cint
end

# FIXME @inline function Tcl_ListObjIndex(intptr::Ptr{Tcl_Interp}, listptr::Ptr{Tcl_Obj},
# FIXME                                   index::Integer)
# FIXME     objptr = Ref{Ptr{Tcl_Obj}}()
# FIXME     return (ccall((:Tcl_ListObjIndex, libtcl), TclStatus,
# FIXME                   (Ptr{Tcl_Interp}, Ptr{Tcl_Obj}, Cint, Ptr{Ptr{Tcl_Obj}}),
# FIXME                   intptr, listptr, index - 1, objptr),
# FIXME             objptr[])
# FIXME end

function Tcl_ListObjReplace(interp, list, first, count, objc, objv)
    @ccall libtcl.Tcl_ListObjReplace(interp::Ptr{Tcl_Interp}, list::Ptr{Tcl_Obj},
                                     first::Cint, count::Cint, objc::Cint,
                                     objv::Ptr{Ptr{Tcl_Obj}})::Cint
end

# FIXME """
# FIXME ```julia
# FIXME Tcl_ListObjReplace(intptr, listptr, first, count,
# FIXME                    objc, objv) -> status::TclStatus
# FIXME ```
# FIXME
# FIXME `first` can be the length of the list plus one and `count` can be 0 to append
# FIXME to the end of the list.
# FIXME
# FIXME `objc = 0` and `objv = NULL` are OK to delete elements.
# FIXME
# FIXME The object referenced by `listptr` must not be shared (its reference count must
# FIXME be ≤ 1) otherwise  Tcl will panic (and abort the program).  To avoid aborting,
# FIXME an error is reported.
# FIXME
# FIXME If `listptr` does not already point to a list value, an attempt will be made to
# FIXME convert it to one.
# FIXME
# FIXME """
# FIXME @inline function Tcl_ListObjReplace(intptr::Ptr{Tcl_Interp}, listptr::Ptr{Tcl_Obj},
# FIXME                                     first::Integer, count::Integer,
# FIXME                                     objc::Integer, objv::Ptr{Ptr{Tcl_Obj}})
# FIXME     if Tcl_IsShared(listptr)
# FIXME         msg = "modifying a shared Tcl list is forbidden"
# FIXME         if intptr == C_NULL
# FIXME             warn(msg, once=true)
# FIXME         else
# FIXME             Tcl_SetResult(intptr, msg)
# FIXME         end
# FIXME         return TCL_ERROR
# FIXME     end
# FIXME     return ccall((:Tcl_ListObjReplace, libtcl), TclStatus,
# FIXME                  (Ptr{Tcl_Interp}, Ptr{Tcl_Obj}, Cint, Cint, Cint, Ptr{Ptr{Tcl_Obj}}),
# FIXME                  intptr, listptr, first + 1, count, objc, objv)
# FIXME end

end # module
