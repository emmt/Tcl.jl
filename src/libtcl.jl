# libtcl.jl -
#
# Glue code to Tcl C library. This should reflect the C API but some notable changes are:
#
# - Tcl status code is returned as a `TclStatus`, not a `Cint`.
#
# - Opaque structures are defined as Julia abstract types.
#
# - Callbacks and procedures (with C type `Tcl_*Proc`) are `Ptr{Cvoid}` as generated by
#   `@cfunction`.
#
# To benefit the most form julia conversion mechanism, argument are not typed. It is left to
# the caller to:
#
# - Provide preserved pointers (can be done thanks to `Base.unsafe_convert`).
#
# - Convert to an `Int` values representing a length or an index which are `Cint` for Tcl.
#
# - Convert to a `Bool` Boolean values returned as `Cint` by Tcl. It is sufficient to
#   do `!iszero(bool))`.

"""
    TclStatus

Type of result returned by evaluating Tcl scripts or commands. Possible values are:

* `TCL_OK`: Command completed normally; the interpreter's result contains the command's
  result.

* `TCL_ERROR`: The command couldn't be completed successfully; the interpreter's result
  describes what went wrong.

* `TCL_RETURN`: The command requests that the current function return; the interpreter's
  result contains the function's return value.

* `TCL_BREAK`: The command requests that the innermost loop be exited; the interpreter's
  result is meaningless.

* `TCL_CONTINUE`: Go on to the next iteration of the current loop; the interpreter's result
  is meaningless.

"""
@cenum TclStatus::Cint begin
    TCL_OK       = 0
    TCL_ERROR    = 1
    TCL_RETURN   = 2
    TCL_BREAK    = 3
    TCL_CONTINUE = 4
end

# Procedures to be called by Tcl can be generated by `@cfunction` which returns a
# `Ptr{Cvoid}`.
const Tcl_CmdDeleteProc = Cvoid
const Tcl_CmdProc = Cvoid
const Tcl_FreeProc = Cvoid
const Tcl_IdleProc = Cvoid
const Tcl_ObjCmdProc = Cvoid

const Tcl_FreeInternalRepProc = Cvoid
const Tcl_DupInternalRepProc = Cvoid
const Tcl_UpdateStringProc = Cvoid
const Tcl_SetFromAnyProc = Cvoid

# Flags for settings the result.
const TCL_VOLATILE = Ptr{Tcl_FreeProc}(1)
const TCL_STATIC   = Ptr{Tcl_FreeProc}(0)
const TCL_DYNAMIC  = Ptr{Tcl_FreeProc}(3)

# Flags for evaluating scripts/commands.
const TCL_NO_EVAL       = Cint(0x010000)
const TCL_EVAL_GLOBAL   = Cint(0x020000)
const TCL_EVAL_DIRECT   = Cint(0x040000)
const TCL_EVAL_INVOKE   = Cint(0x080000)
const TCL_CANCEL_UNWIND = Cint(0x100000)
const TCL_EVAL_NOERR    = Cint(0x200000)

# Tcl wide integer is 64-bit integer.
const WideInt = Int64

# Client data used by commands and callbacks.
const ClientData = Ptr{Cvoid}

# Opaque structures.
abstract type Tcl_Obj end
abstract type Tcl_Interp end
abstract type Tcl_Command_ end
abstract type mp_int end

# Token used by Tcl to identify an object command.
const Tcl_Command = Ptr{Tcl_Command_}

# Tcl version.
const TCL_ALPHA_RELEASE = Cint(0)
const TCL_BETA_RELEASE  = Cint(1)
const TCL_FINAL_RELEASE = Cint(2)
function Tcl_GetVersion(major, minor, patchLevel, type)
    @ccall libtcl.Tcl_GetVersion(major::Ptr{Cint}, minor::Ptr{Cint}, patchLevel::Ptr{Cint},
                                 type::Ptr{Cint})::Cvoid
end

#----------------------------------------------------------------------------- Tcl objects -

"""
    Tcl_ObjType

Julia equivalent type of C structure `Tcl_ObjType` defined in `<tcl.h>`.

"""
struct Tcl_ObjType
    name::Cstring
    freeIntRepProc::Ptr{Tcl_FreeInternalRepProc}
    dupIntRepProc::Ptr{Tcl_DupInternalRepProc}
    updateStringProc::Ptr{Tcl_UpdateStringProc}
    setFromAnyProc::Ptr{Tcl_SetFromAnyProc}
end

# Define constants for the types and offsets of all fields of `Tcl_ObjType`.
for (index, name) in enumerate(fieldnames(Tcl_ObjType))
    @eval begin
        const $(Symbol("Tcl_ObjType_",name,"_type")) = $(fieldtype(Tcl_ObjType, index))
        const $(Symbol("Tcl_ObjType_",name,"_offset")) = $(fieldoffset(Tcl_ObjType, index))
    end
end

"""
    FakeObj{T,N}

Julia equivalent type of C structure `Tcl_Obj` assuming member `internalRep` is of type `T`
and preceded by a padding of `N` bytes. This is used to compute the types and offsets of the
fields of a `Tcl_Obj` and the full size of a `Tcl_Obj`.

The definition of `Tcl_obj` in `<tcl.h>` is:

```c
typedef struct Tcl_ObjType Tcl_ObjType;
typedef struct Tcl_Obj {
    int refCount;
    char *bytes;
    int length;
    const Tcl_ObjType *typePtr;
    union {
        long longValue;
        double doubleValue;
        void *otherValuePtr;
        WideInt wideValue;
        struct {
            void *ptr1;
            void *ptr2;
        } twoPtrValue;
        struct {
            void *ptr;
            unsigned long value;
        } ptrAndLongRep;
    } internalRep;
} Tcl_Obj;
```

"""
struct FakeObj{T,N}
    refCount::Cint
    bytes::Ptr{Cchar}
    length::Cint
    typePtr::Ptr{Tcl_ObjType}
    padding::NTuple{N,UInt8}
    internalRep::T
end

# Tuple of possible types in `internalRep` union.
const Tcl_Obj_internalRep_types = (Clong, Cdouble, Ptr{Cvoid}, WideInt,
                                   Tuple{Ptr{Cvoid}, Ptr{Cvoid}},
                                   Tuple{Ptr{Cvoid}, Culong})

# Define constants for the types and offsets of all fields but the last ones.
for (index, name) in enumerate(fieldnames(FakeObj{Nothing,0}))
    name == :padding && break
    @eval begin
        const $(Symbol("Tcl_Obj_",name,"_type")) = $(fieldtype(FakeObj{Nothing,0}, index))
        const $(Symbol("Tcl_Obj_",name,"_offset")) = $(fieldoffset(FakeObj{Nothing,0}, index))
    end
end

# Alignment of `internalRep` union is the maximal alignment of the different possible types.
const Tcl_Obj_internalRep_align = maximum(map(alignment, Tcl_Obj_internalRep_types))
const Tcl_Obj_internalRep_offset = roundup(sizeof(FakeObj{Nothing,0}), Tcl_Obj_internalRep_align)
const Tcl_Obj_internalRep_pad = Tcl_Obj_internalRep_offset - sizeof(FakeObj{Nothing,0})

# NOTE The number of padding bytes `N` must be an `Int` otherwise the result is wrong.
const Tcl_Obj_size = maximum(map(T -> sizeof(FakeObj{T,Int(Tcl_Obj_internalRep_pad)}),
                                 Tcl_Obj_internalRep_types))

# NOTE Some initialization are needed before calling `TclFreeObj`. This may be done by
#      creating an interpreter.
function TclFreeObj(objPtr::Ptr{Tcl_Obj})
    @ccall libtcl.TclFreeObj(objPtr::Ptr{Tcl_Obj})::Cvoid
end

"""
    Tcl.Private.Tcl_GetRefCount(objptr) -> refcnt

Return the current reference count of the Tcl object at address `objptr`.

This is not provided in `<tcl.h>` but is useful.

!!! warning
    Unsafe function: object pointer must not be null and must remain valid during the call
    to this function.

# See also

[`Tcl.Private.Tcl_IncrRefCount`](@ref) and [`Tcl.Private.Tcl_DecrRefCount`](@ref).

"""
function Tcl_GetRefCount(objPtr::Ptr{Tcl_Obj})
    refCountPtr = Ptr{Tcl_Obj_refCount_type}(objPtr + Tcl_Obj_refCount_offset)
    return unsafe_load(refCountPtr)
end

"""
    Tcl.Private.Tcl_IncrRefCount(objptr) -> objptr

Increment the reference count of the Tcl object given its pointer and return it.

This method emulates the `Tcl_IncrRefCount` macro defined in `<tcl.h>`.

!!! warning
    Unsafe function: object pointer must not be null and must remain valid during the call
    to this function.

# See also

[`Tcl.Private.Tcl_DecrRefCount`](@ref) and [`Tcl.Private.Tcl_GetRefCount`](@ref).

"""
function Tcl_IncrRefCount(objPtr::Ptr{Tcl_Obj})
    refCountPtr = Ptr{Tcl_Obj_refCount_type}(objPtr + Tcl_Obj_refCount_offset)
    refCount = unsafe_load(refCountPtr) + one(Tcl_Obj_refCount_type)
    unsafe_store!(refCountPtr, refCount)
    return objPtr
end

"""
    Tcl.Private.Tcl_DecrRefCount(objptr) -> refcnt

Decrement the reference count of the Tcl object given its pointer and return its new
reference count. If `refcnt < 1` holds, the Tcl object has been released and `objptr` shall
no longer be used.

This method emulates the `Tcl_DecrRefCount` macro defined in `<tcl.h>`.

!!! warning
    Unsafe function: object pointer must not be null and must remain valid during the call
    to this function.

# See also

[`Tcl.Private.Tcl_IncrRefCount`](@ref) and [`Tcl.Private.Tcl_GetRefCount`](@ref).

"""
function Tcl_DecrRefCount(objPtr::Ptr{Tcl_Obj})
    refCountPtr = Ptr{Tcl_Obj_refCount_type}(objPtr + Tcl_Obj_refCount_offset)
    refCount = unsafe_load(refCountPtr) - one(Tcl_Obj_refCount_type)
    unsafe_store!(refCountPtr, refCount)
    refCount < one(refCount) && TclFreeObj(objPtr)
    return refCount
end

# Emulate the `Tcl_IsShared` macro.
Tcl_IsShared(objPtr::Ptr{Tcl_Obj}) = Tcl_GetRefCount(objPtr) > one(Tcl_Obj_refCount_type)

function Tcl_DuplicateObj(objPtr)
    @ccall libtcl.Tcl_DuplicateObj(objPtr::Ptr{Tcl_Obj})::Ptr{Tcl_Obj}
end

function Tcl_GetObjType(typeName)
    @ccall libtcl.Tcl_GetObjType(typeName::Cstring)::Ptr{Tcl_ObjType}
end

# Numbers.
#
# NOTE In object accessors, the interpreter may be NULL, if non-NULL, it is only used to
#      store an error message in case of failure.
#
for (name, type) in ("Boolean" => :Cint,
                     "Int"     => :Cint,
                     "Long"    => :Clong,
                     "Double"  => :Cdouble,
                     "WideInt" => :WideInt,
                     )
    creator = Symbol("Tcl_New",name,"Obj")
    mutator = Symbol("Tcl_Set",name,"Obj")
    accessor = Symbol("Tcl_Get",name,"FromObj")
    @eval begin
        function $creator(val)
            @ccall libtcl.$creator(val::$type)::Ptr{Tcl_Obj}
        end
        function $mutator(obj, val)
            @ccall libtcl.$mutator(obj::Ptr{Tcl_Obj}, val::$type)::Cvoid
        end
        function $accessor(interp, obj, ptr)
            @ccall libtcl.$accessor(interp::Ptr{Tcl_Interp}, obj::Ptr{Tcl_Obj},
                                    ptr::Ptr{$type})::TclStatus
        end
    end
end

# Strings.

function Tcl_NewStringObj(str, len)
    @ccall libtcl.Tcl_NewStringObj(str::Ptr{UInt8}, len::Cint)::Ptr{Tcl_Obj}
end

function Tcl_SetStringObj(obj, str, len)
    @ccall libtcl.Tcl_SetStringObj(obj::Ptr{Tcl_Obj}, str::Ptr{UInt8}, len::Cint)::Cvoid
end

function Tcl_GetString(obj)
    @ccall libtcl.Tcl_GetStringFromObj(obj::Ptr{Tcl_Obj})::Cstring
end

function Tcl_GetStringFromObj(obj, lenPtr)
    @ccall libtcl.Tcl_GetStringFromObj(obj::Ptr{Tcl_Obj}, lenPtr::Ptr{Cint})::Ptr{UInt8}
end

# Multi-precision integers. TODO "Bignum" => :BigInt

function Tcl_NewBignumObj(value)
    @ccall libtcl.Tcl_NewBignumObj(value::Ptr{mp_int})::Ptr{Tcl_Obj}
end

function Tcl_SetBignumObj(obj, value)
    @ccall libtcl.Tcl_SetBignumObj(obj::Ptr{Tcl_Obj}, value::Ptr{mp_int})::Cvoid
end

function Tcl_GetBignumFromObj(interp, obj, value)
    @ccall libtcl.Tcl_GetBignumFromObj(interp::Ptr{Tcl_Interp}, obj::Ptr{Tcl_Obj},
                                       value::Ptr{mp_int})::TclStatus
end

function Tcl_TakeBignumFromObj(interp, obj, value)
    @ccall libtcl.Tcl_TakeBignumFromObj(interp::Ptr{Tcl_Interp}, obj::Ptr{Tcl_Obj},
                                        value::Ptr{mp_int})::TclStatus
end

# Byte arrays.

function Tcl_NewByteArrayObj(bytes, numBytes)
    @ccall libtcl.Tcl_NewByteArrayObj(bytes::Ptr{Cuchar}, numBytes::Cint)::Ptr{Tcl_Obj}
end

function Tcl_GetByteArrayFromObj(objPtr, numBytesPtr)
    @ccall libtcl.Tcl_GetByteArrayFromObj(objPtr::Ptr{Tcl_Obj},
                                          numBytesPtr::Ptr{Cint})::Ptr{UInt8}
end

function Tcl_SetByteArrayLength(objPtr, numBytes)
    @ccall libtcl.Tcl_SetByteArrayLength(objPtr::Ptr{Tcl_Obj}, numBytes::Cint)::Ptr{UInt8}
end

function Tcl_SetByteArrayObj(objPtr, bytes, numBytes)
    @ccall libtcl.Tcl_SetByteArrayObj(objPtr::Ptr{Tcl_Obj}, bytes::Ptr{Cuchar},
                                      numBytes::Cint)::Cvoid
end

#------------------------------------------------------------------------ Tcl interpreters -

function Tcl_CreateInterp()
    @ccall libtcl.Tcl_CreateInterp()::Ptr{Tcl_Interp}
end

function Tcl_Init(interp)
    @ccall libtcl.Tcl_Init(interp::Ptr{Tcl_Interp})::TclStatus
end

# NOTE This function is very fast.
function Tcl_InterpDeleted(interp)
    @ccall libtcl.Tcl_InterpDeleted(interp::Ptr{Tcl_Interp})::Cint
end

# NOTE This function is very fast.
function Tcl_InterpActive(interp)
    @ccall libtcl.Tcl_InterpActive(interp::Ptr{Tcl_Interp})::Cint
end

function Tcl_IsSafe(interp)
    @ccall libtcl.Tcl_IsSafe(interp::Ptr{Tcl_Interp})::Cint
end

function Tcl_DeleteInterp(interp)
    @ccall libtcl.Tcl_DeleteInterp(interp::Ptr{Tcl_Interp})::Cvoid
end

function Tcl_SetObjResult(interp, obj)
    @ccall libtcl.Tcl_SetObjResult(interp::Ptr{Tcl_Interp}, obj::Ptr{Tcl_Obj})::Cvoid
end

function Tcl_SetResult(interp, result, freeProc)
    @ccall libtcl.Tcl_SetResult(interp::Ptr{Tcl_Interp}, result::Cstring,
                                freeProc::Ptr{Tcl_FreeProc})::Cvoid
end

function Tcl_GetStringResult(interp)
    @ccall libtcl.Tcl_GetStringResult(interp::Ptr{Tcl_Interp})::Cstring
end

function Tcl_GetObjResult(interp)
    @ccall libtcl.Tcl_GetObjResult(interp::Ptr{Tcl_Interp})::Ptr{Tcl_Obj}
end

# Reference counting.

function Tcl_Preserve(data)
    @ccall libtcl.Tcl_Preserve(data::ClientData)::Cvoid
end

function Tcl_Release(data)
    @ccall libtcl.Tcl_Release(data::ClientData)::Cvoid
end

#--------------------------------------------------------------- Evaluation of Tcl scripts -

function Tcl_Eval(interp, script)
    @ccall libtcl.Tcl_Eval(interp::Ptr{Tcl_Interp}, script::Cstring)::TclStatus
end

function Tcl_EvalFile(interp, fileName)
    @ccall libtcl.Tcl_EvalFile(interp::Ptr{Tcl_Interp}, fileName::Cstring)::TclStatus
end

function Tcl_EvalEx(interp, script, numBytes, flags)
    @ccall libtcl.Tcl_EvalEx(interp::Ptr{Tcl_Interp}, script::Ptr{UInt8}, numBytes::Cint,
                             flags::Cint)::TclStatus
end

function Tcl_EvalObjEx(interp, obj, flags)
    @ccall libtcl.Tcl_EvalObjEx(interp::Ptr{Tcl_Interp}, obj::Ptr{Tcl_Obj},
                                flags::Cint)::TclStatus
end

function Tcl_EvalObjv(interp, objc, objv, flags)
    @ccall libtcl.Tcl_EvalObjv(interp::Ptr{Tcl_Interp}, objc::Cint,
                               objv::Ptr{Ptr{Tcl_Obj}}, flags::Cint)::TclStatus
end

#------------------------------------------------------------------------------ Tcl events -

# Flags for Tcl processing events. Set TCL_DONT_WAIT to not sleep: process only events that
# are ready at the time of the call. Set TCL_ALL_EVENTS to process all kinds of events:
# equivalent to OR-ing together all of the below flags or specifying none of them.
const TCL_DONT_WAIT     = Cint(1<<1)
const TCL_WINDOW_EVENTS = Cint(1<<2) # Process window system events.
const TCL_FILE_EVENTS   = Cint(1<<3) # Process file events.
const TCL_TIMER_EVENTS  = Cint(1<<4) # Process timer events.
const TCL_IDLE_EVENTS   = Cint(1<<5) # Process idle callbacks.
const TCL_ALL_EVENTS    = ~TCL_DONT_WAIT      # Process all kinds of events.

function Tcl_DoOneEvent(flags)
    @ccall libtcl.Tcl_DoOneEvent(flags::Cint)::Cint
end

function Tcl_DoWhenIdle(proc, clientData)
    @ccall libtcl.Tcl_DoWhenIdle(proc::Ptr{Tcl_IdleProc}, clientData::ClientData)::Cvoid
end

#---------------------------------------------------------------------------- Tcl commands -

function Tcl_CreateCommand(interp, cmdName, proc, clientData, deleteProc)
    @ccall libtcl.Tcl_CreateCommand(interp::Ptr{Tcl_Interp}, cmdName::Cstring,
                                    proc::Ptr{Tcl_CmdProc}, clientData::ClientData,
                                    deleteProc::Ptr{Tcl_CmdDeleteProc})::Tcl_Command
end

function Tcl_CreateObjCommand(interp, cmdName, proc, clientData, deleteProc)
    @ccall libtcl.Tcl_CreateObjCommand(interp::Ptr{Tcl_Interp}, cmdName::Cstring,
                                       proc::Ptr{Tcl_ObjCmdProc}, clientData::ClientData,
                                       deleteProc::Ptr{Tcl_CmdDeleteProc})::Tcl_Command
end

function Tcl_DeleteCommand(interp, cmdName)
    @ccall libtcl.Tcl_DeleteCommand(interp::Ptr{Tcl_Interp}, cmdName::Cstring)::Cint
end

function Tcl_DeleteCommandFromToken(interp, command)
    @ccall libtcl.Tcl_DeleteCommandFromToken(interp::Ptr{Tcl_Interp},
                                             command::Tcl_Command)::Cint
end

function Tcl_GetCommandName(interp, command)
    @ccall libtcl.Tcl_GetCommandName(interp::Ptr{Tcl_Interp}, command::Tcl_Command)::Cstring
end

function Tcl_GetCommandFullName(interp, command, objPtr)
    @ccall libtcl.Tcl_GetCommandFullName(interp::Ptr{Tcl_Interp}, command::Tcl_Command,
                                         objPtr::Ptr{Tcl_Obj})::Cvoid
end

function Tcl_GetCommandFromObj(interp, objPtr)
    @ccall libtcl.Tcl_GetCommandFromObj(interp::Ptr{Tcl_Interp},
                                        objPtr::Ptr{Tcl_Obj})::Tcl_Command
end

#--------------------------------------------------------------------------- Tcl variables -

# Flags for Tcl variables.
const TCL_GLOBAL_ONLY    = Cint(1)
const TCL_NAMESPACE_ONLY = Cint(2)
const TCL_APPEND_VALUE   = Cint(4)
const TCL_LIST_ELEMENT   = Cint(8)
const TCL_LEAVE_ERR_MSG  = Cint(0x200)

function Tcl_GetVar(interp, name, flags)
    @ccall libtcl.Tcl_GetVar(interp::Ptr{Tcl_Interp}, name::Cstring, flags::Cint)::Cstring
end

function Tcl_GetVar2(interp, part1, part2, flags)
    @ccall libtcl.Tcl_GetVar2(interp::Ptr{Tcl_Interp}, part1::Cstring, part2::Cstring,
                              flags::Cint)::Cstring
end

function Tcl_GetVar2Ex(interp, part1, part2, flags)
    @ccall libtcl.Tcl_GetVar2Ex(interp::Ptr{Tcl_Interp}, part1::Cstring, part2::Cstring,
                                flags::Cint)::Ptr{Tcl_Obj}
end

function Tcl_ObjGetVar2(interp, part1, part2, flags)
    @ccall libtcl.Tcl_ObjGetVar2(interp::Ptr{Tcl_Interp}, part1::Ptr{Tcl_Obj},
                                 part2::Ptr{Tcl_Obj}, flags::Cint)::Ptr{Tcl_Obj}
end

function Tcl_SetVar(interp, name, value, flags)
    @ccall libtcl.Tcl_SetVar(interp::Ptr{Tcl_Interp}, name::Cstring,
                              value::Cstring, flags::Cint)::Cstring
end

function Tcl_SetVar2(interp, part1, part2, value, flags)
    @ccall libtcl.Tcl_SetVar2(interp::Ptr{Tcl_Interp}, part1::Cstring, part2::Cstring,
                              value::Cstring, flags::Cint)::Cstring
end

function Tcl_SetVar2Ex(interp, part1, part2, newValuePtr, flags)
    @ccall libtcl.Tcl_SetVar2Ex(interp::Ptr{Tcl_Interp}, part1::Cstring, part2::Cstring,
                                newValuePtr::Ptr{Tcl_Obj}, flags::Cint)::Ptr{Tcl_Obj}
end

function Tcl_ObjSetVar2(interp, part1, part2, value, flags)
    @ccall libtcl.Tcl_ObjSetVar2(interp::Ptr{Tcl_Interp}, part1::Ptr{Tcl_Obj},
                                 part2::Ptr{Tcl_Obj}, value::Ptr{Tcl_Obj},
                                 flags::Cint)::Ptr{Tcl_Obj}
end

function Tcl_UnsetVar(interp, name, flags)
    @ccall libtcl.Tcl_UnsetVar(interp::Ptr{Tcl_Interp}, name::Cstring,
                               flags::Cint)::TclStatus
end

function Tcl_UnsetVar2(interp, part1, part2, flags)
    @ccall libtcl.Tcl_UnsetVar2(interp::Ptr{Tcl_Interp}, part1::Cstring,
                                part2::Cstring, flags::Cint)::TclStatus
end

#------------------------------------------------------------------------------- Tcl lists -
#
# Note that applying a list function to any Tcl object has the side effect of converting the
# object to a list. In principle, non-temporary objects cannot be modified.

function Tcl_NewListObj(objc, objv)
    @ccall libtcl.Tcl_NewListObj(objc::Cint, objv::Ptr{Ptr{Tcl_Obj}})::Ptr{Tcl_Obj}
end

function Tcl_SetListObj(list, objc, objv)
    @ccall libtcl.Tcl_SetListObj(list::Ptr{Tcl_Obj}, objc::Cint,
                                 objv::Ptr{Ptr{Tcl_Obj}})::Cvoid
end

function Tcl_ListObjAppendList(interp, listPtr, elemListPtr)
    @ccall libtcl.Tcl_ListObjAppendList(interp::Ptr{Tcl_Interp}, listPtr::Ptr{Tcl_Obj},
                                        elemListPtr::Ptr{Tcl_Obj})::TclStatus
end

function Tcl_ListObjAppendElement(interp, listPtr, objPtr)
    @ccall libtcl.Tcl_ListObjAppendElement(interp::Ptr{Tcl_Interp}, listPtr::Ptr{Tcl_Obj},
                                           objPtr::Ptr{Tcl_Obj})::TclStatus
end

function Tcl_ListObjGetElements(interp, listPtr, objcPtr, objvPtr)
    @ccall libtcl.Tcl_ListObjGetElements(interp::Ptr{Tcl_Interp}, listPtr::Ptr{Tcl_Obj},
                                         objcPtr::Ptr{Cint},
                                         objvPtr::Ptr{Ptr{Ptr{Tcl_Obj}}})::TclStatus
end

function Tcl_ListObjLength(interp, list, lengthPtr)
    @ccall libtcl.Tcl_ListObjLength(interp::Ptr{Tcl_Interp}, list::Ptr{Tcl_Obj},
                                    lengthPtr::Ptr{Cint})::TclStatus
end

function Tcl_ListObjIndex(interp, list, index, objPtrPtr)
    @ccall libtcl.Tcl_ListObjIndex(interp::Ptr{Tcl_Interp}, list::Ptr{Tcl_Obj},
                                   index::Cint, objPtrPtr::Ptr{Ptr{Tcl_Obj}})::TclStatus
end

function Tcl_ListObjReplace(interp, list, first, count, objc, objv)
    @ccall libtcl.Tcl_ListObjReplace(interp::Ptr{Tcl_Interp}, list::Ptr{Tcl_Obj},
                                     first::Cint, count::Cint, objc::Cint,
                                     objv::Ptr{Ptr{Tcl_Obj}})::TclStatus
end
